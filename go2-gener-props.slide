Go2 Generics

Go! Academy
5 December 2018

Katarzyna Rybacka
Software Engineer, Codilime
katarzyna.rybacka@codilime.com
Tags: Go, generics

* Agenda

1. What's next? Go2 goals
2. Generics. Why now?
3. What we want from generics in Go?
4. Draft Designs
5. Possible problems
6. Open questions

* Introduction

* Go2

 - Error handling
 - Error values
 - Generics

* Generics

* "Generic programming is a style of computer programming in which algorithms are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters."
* "Generalization based on type parameters was called parametric polymorphism."

* Approaches

- C approach - slow programmers
- C++ approach - slow compilation*
- Java approach - slow execution

* Why does Go not have generic types now?

* "Instead of attempting Generics at the start, we spent our time on features more directly applicable to Go’s initial target of networked system software (now “cloud software”),
such as concurrency, scalable builds, and low-latency garbage collection."

* Goals

* 
- Fit smoothly into language
- No awkward special cases
- No exposing implementation details
- Dual implementation
: Polymorphism in Go should be implementable both at compile time (by repeated specialized compilation, as in C++) and at run time
- Preserve straightforward and understandable style
- As little added complexity as possible

* Example

    // Keys returns the keys from a map.
    func Keys(m map[K]V) []K

    // Uniq filters repeated elements from a channel,
    // returning a channel of the filtered data.
    func Uniq(<-chan T) <-chan T

    // Merge merges all data received on any of the channels,
    // returning a channel of the merged data.
    func Merge(chans ...<-chan T) <-chan T

    // SortSlice sorts a slice of data using the given comparison function.
    func SortSlice(data []T, less func(x, y T) bool)

* Draft Designs

- Type functions
: Functions parameterized by types
- Generalized types
- Contracts
- Type parameters
: Types parameterized by types
* Type parameters

    func Keys(type K, V)(m map[K]V) []K

Uses of a parameterized declaration supply the type arguments using ordinary call syntax:

    var ints List(int)

    keys := Keys(int, string)(map[int]string{1:"one", 2: "two"})

: In general an implementation may need to constrain the possible types that can be used.
: For example, we might want to define a Set(T), implemented as a list or map, in which case values of type T must be able to be compared for equality.
: To express that, the draft design introduces the idea of a named contract.
: A contract is like a function body illustrating the operations the type must support.
: For example, to declare that values of type T must be comparable:

* Generalized types

    type List(type T) []T

    type IndexedSet(type T) []T

* Contracts
* Take a look at parameterized structures

    // T must satisfy the `Comparable` contract. This is shorthand for (type T Comparable(T))
    type IndexedSet(type T Comparable) []T

    contract Comparable(t T) {
        t == t // assert that t must be able to use the `==` operator.
    }


: https://twitter.com/rogpeppe/status/1036008488143646722 - considel adding Comparable contract

* But don't forget about functions..

    contract Addable(t T) {
        t + t
    }

    // (type T Addable) is shorthand for (type T Addable(T))
    func Sum(type T Addable)(x []T) T {
        var total T
        for _, v := range x {
            total += v
        }
        return total
    }


* Possible problems

* Implied constraints.

    // Maps must have the `==` operator defined on their keys.
    // Then the question begs, should the following function compile properly?
    // Or should we be required to make a contract for K?
    func Keys(type K, V)(m map[K]V) []K

    // alternatively...

    contract Equal(t T) {
        t == t
    }

    // Now, we apply the Equal contract to K
    func Keys(type K, V Equal(K))(m map[K]V) []K

* Dual implementation

    // A Set is a set of values of type T.
    type Set(type T) ...

    // Apply applies the function f to each value in the set s,
    // returning a set of the results.
    func (s Set(T)) Apply(type U)(f func(T) U) Set(U)  // NOT ALLOWED!

    // OK
    type List(type T) struct {
        elem T
        next *List(T)
    }

*
    // NOT OK - Implies an infinite sequence of types as you follow .next pointers.
    type Infinite(type T) struct {
        next *Infinite(Infinite(T))
    }

    // BigArray(T)(n) returns a nil n-dimensional slice of T.
    // BigArray(int)(1) returns []int
    // BigArray(int)(2) returns [][]int
    // ...
    func BigArray(type T)(n int) interface{} {
        if n <= 1 || n >= 1000000000 {
            return []T(nil)
        }
        return BigArray([]T)(n-1)
    }

* Contract bodies? Not so simple

* This way..

    contract C(t T) {
        if t == t {
            for i := 0; i < t; i++ {
                t = t + t
                t = t * t
            }
        }
    }

* Or maybe..

    contract C(t T) {
        t == t       // T is comparable
        0 < t        // T is relational to integers
        t = t + t    // T is assignable and has a + operator
        t = t * t    // T is assignable and has a * operator
    }

* Syntax

*
    func (Receiver) FuncName(Generic Type List)(Argument List) (Return Value List)

* Thanks! :)

* Reference
- https://dev.to/deanveloper/go-2-draft-generics-3333
- https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md